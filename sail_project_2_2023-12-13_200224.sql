-- MySQL dump 10.13  Distrib 8.0.34, for Linux (x86_64)
--
-- Host: 127.0.0.1    Database: sail_project_2
-- ------------------------------------------------------
-- Server version	8.0.32

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `article_category`
--

DROP TABLE IF EXISTS `article_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article_category` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `article_id` bigint unsigned NOT NULL,
  `category_id` bigint unsigned NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `article_category_article_id_foreign` (`article_id`),
  KEY `article_category_category_id_foreign` (`category_id`),
  CONSTRAINT `article_category_article_id_foreign` FOREIGN KEY (`article_id`) REFERENCES `articles` (`id`) ON DELETE CASCADE,
  CONSTRAINT `article_category_category_id_foreign` FOREIGN KEY (`category_id`) REFERENCES `categories` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=62 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_category`
--

/*!40000 ALTER TABLE `article_category` DISABLE KEYS */;
INSERT INTO `article_category` VALUES (9,13,12,NULL,NULL),(12,19,17,NULL,NULL),(13,20,18,NULL,NULL),(14,21,17,NULL,NULL),(16,23,16,NULL,NULL),(18,25,12,NULL,NULL),(19,26,12,NULL,NULL),(23,14,14,NULL,NULL),(28,28,12,NULL,NULL),(30,24,12,NULL,NULL),(31,22,17,NULL,NULL),(33,30,18,NULL,NULL),(38,10,12,NULL,NULL),(39,31,16,NULL,NULL),(40,35,20,NULL,NULL),(41,36,21,NULL,NULL),(43,37,8,NULL,NULL),(44,27,19,NULL,NULL),(45,11,13,NULL,NULL),(46,38,8,NULL,NULL),(47,39,8,NULL,NULL),(48,40,22,NULL,NULL),(49,41,22,NULL,NULL),(50,42,22,NULL,NULL),(51,43,22,NULL,NULL),(52,44,22,NULL,NULL),(53,45,22,NULL,NULL),(54,46,22,NULL,NULL),(55,47,18,NULL,NULL),(56,48,23,NULL,NULL),(57,17,16,NULL,NULL),(58,49,8,NULL,NULL),(59,50,8,NULL,NULL),(60,51,8,NULL,NULL),(61,52,26,NULL,NULL);
/*!40000 ALTER TABLE `article_category` ENABLE KEYS */;

--
-- Table structure for table `articles`
--

DROP TABLE IF EXISTS `articles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `articles` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `user_id` bigint unsigned NOT NULL,
  `title` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `body` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `tags` json DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `articles_user_id_foreign` (`user_id`),
  CONSTRAINT `articles_user_id_foreign` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `articles`
--

/*!40000 ALTER TABLE `articles` DISABLE KEYS */;
INSERT INTO `articles` VALUES (10,1,'Eloquent','<p>Laravel\'s ActiveRecord implementation is called Eloquent. Interacting with a database in an object-oriented way is the modern standard.</p><p>Our database table users is plural because it signifies that it stores more than one user record. The model class is named User singular because it represents one single user record in the users table. The User class name is capitalized because of the standard for using Pascal case for class names. If your database table was named user_profiles, your model\'s class name would be UserProfile.</p><p>We can see how using conventions prevents us from having to make a bunch of configurations.</p><p>Well, what if we must use a database table that doesn\'t follow conventions? No problem! We can just define the table name manually. Just add the following line to the User class:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public static $table = \'my_users_table\';\n</pre><p>Most conventions in Laravel can be overridden with configuration when necessary.</p><p><br></p><p><em style=\"color: rgb(68, 140, 39);\">Shawn McCool Laravel Starter</em></p>','[\"ActiveRecord\", \"OOP\"]','2023-12-03 10:58:21','2023-12-09 08:39:39'),(11,1,'Artisan','<p>Laravel also ships with a command-line interface tool called Artisan.</p>','[\"command-line interface\"]','2023-12-04 17:20:46','2023-12-10 16:24:18'),(13,1,'Configuration','<p>Open the file application/config/database.php and scan the contents. You\'ll find example configurations for each database driver. Determine which driver you\'re going to use from the available options (sqlite, mysql, pgsql, and sqlserv) and enter the name of the driver as the default database connection.</p><p>Then, in the Connections section add your database name, user, and password.</p><p><br></p><p><em style=\"color: rgb(113, 221, 55);\">Shawn McCool Laravel starter</em></p><p><br></p><p>The provided text appears to be a set of instructions related to Laravel migrations in PHP. Here\'s the translation into English:</p><pre class=\"ql-syntax\" spellcheck=\"false\">php artisan migrate:rollback --step=1\n</pre><p>The number of rolled-back migrations is specified in the --step parameter of the migrate:rollback command.</p><p>Open the module database\\migrations\\&lt;current_timestamp&gt;_create_bbs_table.php in a text editor with our migration and add code to create a foreign key field:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function up() {\n&nbsp;&nbsp;  Schema::create(\'bbs\', function (Blueprint $table) {\n    &nbsp;&nbsp;&nbsp;&nbsp;$table-&gt;float(\'price\');\n&nbsp;&nbsp;&nbsp;&nbsp;    $table-&gt;foreignId(\'user_id\')-&gt;constrained()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  -&gt;onDelete(\'cascade\');\n&nbsp;&nbsp;&nbsp;&nbsp;    $table-&gt;timestamps();\n&nbsp;&nbsp;  });\n}\n</pre><p>The foreignId() method of the table structure object creates a foreign key field and returns an object representing it. We have given this field a meaningful name, user_id, and therefore, to establish the actual relationship, we can call the constrained() method on the returned relationship object. This method extracts all the necessary information from the name: the name of the associated primary table (users) and its primary key field (id). The onDelete() method specifies the operation performed on the associated records in the secondary table when a record in the primary table is deleted (in our case, cascade, i.e., cascading deletion).</p><p><br></p><p><em style=\"color: rgb(113, 221, 55);\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP</em></p>','[\"database driver\", \"database connection\", \"foreignId\", \"foreignkey\", \"cascading deletion\", \"secondary table\", \"primary table\", \"onDelete\", \"rollback\"]','2023-12-05 17:50:00','2023-12-09 11:17:14'),(14,1,'Migrations','<p>You might typically create the users table with a tool like phpMyAdmin or Navicat. But, Laravel provides a fancy migrations system for us and we should use it because it improves our workflow and reduces deployment bugs.</p><p>Migrations are version control for your schema modifications.</p><p>Migrations reduce the amount of headache that we face by requiring us to only define the schema alteration once. Afterwards, we can deploy our changes to any number of systems without the potential for human error The migration files are formatted with the year, month, day, time, and the text that you added that enable it to be identified by a human, in this case create_users_table. Mine looks like 2012_08_16_112327_create_users_table.php. The structure of the filename is important as it helps Laravel to understand the order in which it should run the migrations. By using a convention for naming your migrations, you\'ll be helping your team to better understand your work (and vice-versa). An example convention might consist of entries like create_users_table, add_fields_to_users_table, or rename_blog_posts_table_to_posts.</p><p>Schema::table() accepts two arguments. The first is the name of the table that you\'ll be interacting with, in this case it\'s users. The second argument is a closure which contains your table definition. The closure receives the argument $table and this is the object that we\'ll be interacting with to define the table.</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$table-&gt;create();\n</pre><p>This line tells Laravel that the table will need to be created. If we omit this line, Schema will generate the ALTER TABLE syntax rather than the CREATE TABLE syntax.</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$table-&gt;increments(\'id\');\n</pre><p>The increments() method tells Schema that the specified field should be an utoincremented primary key. With Laravel, you\'ll want to use simple field names such as id, email, and password. If you aren\'t familiar with using Object-Relational Mapping (ORM), you may be in the habit of creating those same field names with the table name as a prefix. For example, user_id, user_email, user_password. The purpose behind defining field names with the table name as a prefix is to simplify query generation when using a query builder. This is no longer necessary and it\'s best to follow the more simple convention as it manages redundant interactions for you, removing the need for you to continuously write the boilerplate code.</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$table-&gt;string(\'email\');\n$table-&gt;string(\'real_name\');\n$table-&gt;string(\'password\');\n</pre><p>Next we have a few string declarations. These will be created as the VARCHAR fields with the default length of 200. You can override the length of these fields by passing a second argument that represents the intended length. For example:</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$table-&gt;string(\'email\', 300);\n</pre><p>This line creates a VARCHAR field named email with a length of 300.</p><p>It\'s important to note that we shouldn\'t reduce the size of the password field as we\'ll need that length for the output from Laravel\'s Hash class.</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$table-&gt;timestamps();\n</pre><p>Finally, we come to the timestamps() method. This will create two DATETIME fields (created_at and updated_at). It is not unreasonable to create the timestamp fields for every table in the database as they can be very useful for troubleshooting down the road. The Eloquent ORM will automatically manage these timestamp fields for us. So, we can forget&nbsp;about them for now.</p><p>The down() method should revert any changes made to the up() method. In this case, the up() method creates a database table called users. So, the down() method should remove the table.&nbsp;</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">Schema::drop(\'users\');\n</pre><p>This is done with the method Schema::drop(). drop() takes a single argument, a string value containing the name of the table that you wish to drop.&nbsp;</p><p>That\'s it! We have our first migration. Once you memorize the commonly used methods such as increments(), string(), decimal(), timestamps(), and date(), you\'ll be able to make migrations just as fast as you were able to modify your database with your preferred database management tool. But, now we gain the added benefit from using them in versioned and collaborative situations.</p><p>Now, we\'re ready to run our migrations. From this point on, running migrations will always be done in the same way. Let\'s go ahead and give it a shot:</p><p># php artisan migrate</p><p>It\'s very important to test our migrations. If we don\'t test our migrations, it could come back to bite us later in the project when we need to roll back migrations and run into an error. Proper migration testing verifies that the up() and down() methods both function as intended.</p><p>To test the up() method, run the migration and open your preferred database management application. Then, verify that everything is as you intended. Then, test the down() method by rolling back the migration and doing the same. Roll back your migration now by using the following command:</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\"># php artisan migrate:rollback\n</pre><p>Optimally, you will be notified that the migration was rolled back successfully. Double-check that your database no longer contains the users table. That\'s it! This migration is good to go.&nbsp;</p><p>Run your migrations for one last time and let\'s move on to the next step.</p><p><br></p><p><em>Shawn McCool Laravel starter</em></p><p><br></p><p>After each Laravel migration is applied, the framework logs a corresponding informational record in the migration log — a special table created in the default database. The migration log table is automatically created before the first application of migrations and is named according to the setting specified in the working configuration file `database.migrations` (by default, it is set to \'migrations\').</p><p><br></p><p>The \"empty\" migration module is created using the following command format:</p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">php artisan make:migration &lt;migration_name&gt; [--table=&lt;table_name&gt;] [--create=&lt;table_name&gt;] [--path=&lt;path&gt; [--realpath]]\n</pre><p>In the migration name, individual words should be separated by underscore symbols. If the migration name follows one of the following formats:</p><p>- `create_&lt;table_name&gt;[_table]` — the migration will include code to create a table with the specified name, adding a primary key, creation timestamp fields, and modification timestamp fields. The migration will also include code to drop this table when the migration is rolled back.</p><p>- `[&lt;arbitrary_text&gt;]_to|from|in_&lt;table_name&gt;[_table]` — the migration will include code to alter the structure of the table with the specified name.</p><p>Otherwise, a completely \"empty\" migration will be created, and the necessary code will need to be written manually.</p><p>The following useful options are supported:</p><p>- `--table`: Forces the inclusion of code in the migration that alters the structure of the table with the specified name for modification, even if the migration name provided in the command does not match the specified template.</p><p>- `--create`: Same as `--table`, but also inserts code to create a primary key, creation timestamp fields, and modification timestamp fields in the table.</p><p>- `--path`: Saves the modules of the created migrations to the specified path. You can specify either a relative path (from the project folder) or an absolute path by adding the `--realpath` flag.</p><p><br></p><p>The creation of a deletion mark field in a table is done by calling one of the following methods of the Blueprint class:</p><p>- `softDeletes([&lt;field name&gt;=\'deleted_at\'[, &lt;precision&gt;=0]])` — creates a deletion mark (of type TIMESTAMP). By default, the created field will be named \'deleted_at\'. The precision parameter indicates the number of digits after the decimal point to store fractions of seconds.</p><p>- `softDeletesTz([&lt;field name&gt;=\'deleted_at\'[, &lt;precision&gt;=0]])` — similar to softDeletes().</p><p>Example:</p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">public function up() {\n&nbsp;&nbsp;  Schema::create(\'bbs\', function (Blueprint $table) {\n&nbsp;&nbsp;&nbsp;&nbsp;    // ...\n&nbsp;&nbsp;&nbsp;&nbsp;    $table-&gt;softDeletes();\n&nbsp;&nbsp;  });\n}\n</pre><p><br></p><p>4.1.4.1. Editing and Deleting Fields</p><p>To edit fields (as well as indexes, which will be discussed later), the table() method is applied to the table, similar to the create() method discussed in section 4.1.3. For example:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">Schema::table(\'rubrics\', function (Blueprint $table) {\n   &nbsp;// Code to modify the table structure is written here\n});\n</pre><p>BEFORE EDITING FIELDS...</p><p>...an additional library, doctrine/dbal, needs to be installed by executing the command:</p><p>composer require doctrine/dbal</p><p>Adding a field is done using the methods described in section 4.1.3.</p><p>Editing a field is a two-step process:</p><p>• Setting new field parameters by calling the necessary method from those described in section 4.1.3.1, specifying the name of the field to be modified and its new parameters. Additional parameters for the field can also be set by calling methods from section 4.1.3.3, and an index can be created by calling methods from section 4.1.3.4.</p><p>• Indicating to modify the field by calling the change() method on the field object.</p><p>Example:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// Adding the \'description\' field to the \'rubrics\' table, then\n// increasing the length of the \'name\' field to 50 characters and creating\n// a unique index based on it\npublic function up() {\n&nbsp;Schema::table(\'rubrics\', function (Blueprint $table) {\n&nbsp;$table-&gt;text(\'description\');\n&nbsp;$table-&gt;string(\'name\', 50)-&gt;unique()-&gt;change();\n&nbsp;});\n}\n</pre><p>Renaming a field is done by calling the renameColumn() method on the table structure:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// Renaming the \'description\' field to \'desc\'\nSchema::table(\'rubrics\', function (Blueprint $table) {\n   &nbsp;$table-&gt;renameColumn(\'description\', \'desc\');\n});\n</pre><p>Deleting a field is done by calling the dropColumn() method on the table structure:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// Deleting the \'desc\' field from the \'rubrics\' table\nSchema::table(\'rubrics\', function (Blueprint $table) {\n&nbsp;   $table-&gt;dropColumn(\'desc\');\n</pre><p>Deleting a system field is done by calling one of the following methods:</p><p>• dropTimestamps() — removes creation and update timestamp fields;</p><p>• dropTimestampsTz() — same as dropTimestamps();</p><p>• dropRememberToken() — removes the remember_token field with an electronic token for user remembrance;</p><p>• dropSoftDeletes() — removes the deletion mark field;</p><p>• dropSoftDeletesTz() — same as dropSoftDeletes().</p><p><br></p><p><em>Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP</em></p>','[\"increments\", \"down\", \"up\", \"ORM\", \"migration log table\", \"create\", \"table\", \"path\", \"softDeletes\", \"change\", \"dropColumn\", \"unique\"]','2023-12-05 17:56:41','2023-12-12 16:36:35'),(15,1,'Hashing','<p>There\'s one important thing that we should add to our user model. We\'re storing the user\'s e-mail address, real name, and password. We want to make sure that the user\'s password isn\'t stored in plain text. We need to hash their password before it is stored in the database. For this we\'ll create a setter.</p><p>A setter is a method that intercepts the assignment of an attribute. In this case, we\'re going to intercept the assignment of the password attribute, hash the value that we received, and then store the hashed value in the database.</p><p>Let\'s look at some code.</p><pre class=\"ql-syntax\" spellcheck=\"false\">class User extends Eloquent\n{\n&nbsp;public function set_password($string)\n&nbsp;{\n&nbsp;$this-&gt;set_attribute(\'password\', Hash::make($string));\n&nbsp;}\n}\n</pre><p>As you can see, the convention for declaring setters is to prefix the name of the attribute whose assignments you want to intercept with set_. The user\'s password will be passed to the setter as the argument $string.</p><p>We use the set_attribute() method to store a hashed version of the user\'s password into the model. Typically the set_attribute() method is not necessary. But, we don\'t want our setter to be stuck in an endless loop as we continuously attempt to assign $this-&gt;password. The set_attribute() method accepts two arguments. The first is the name of the attribute and the second is the value that we want to assign to it. When assigning values with set_attribute(), setter methods will not be called and the data will be directly modified within the model.</p><p>We\'re using the make() method from Laravel\'s Hash class to create a salted hash of the&nbsp;user\'s password.</p>','[\"password\", \"setter\"]','2023-12-05 18:09:56','2023-12-07 13:55:52'),(17,1,'Routing','<p>Before we can move on and test our user model, we need to know a few things about routing in Laravel. Routing is the act of linking a URL to a function in your application. In Laravel, it\'s possible to route in two ways. You can either route to a closure or a controller action. As we\'ll be going over controllers in more detail later, let\'s start by looking at how we can route to a closure.&nbsp;</p><p>Routes in Laravel are declared in application/routes.php. This file will represent the connection between your site\'s URLs and the functions that contain application logic for your site. This is very handy as other developers will be able to come into your project and know how requests are routed, simply by reviewing this file.</p><p>Here is a simple example of routing to a closure:</p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">Route::get(\'test\', function()\n{\n&nbsp;return \"This is the test route.\";\n});\n</pre><p>We\'re using the Route::get() method to define the route. Route::get() registers a closure with the router that specifically responds to a GET request at the specified URI. To register a closure for the POST, PUT, and DELETE requests, you\'d use Route::post(), Route::put(), and Route::delete() respectively. These methods correspond to what are commonly referred to as the HTTP verbs.</p><p>Typically, developers only interact with the GET and POST requests. When a user clicks on a link or enters a URL in their address bar, they\'re creating a GET request. When a user submits a form, they\'re typically creating a POST request.</p><p>The first argument for the Route::get() method is the URI for the route (the part of the URL after the domain name), and the second argument is the closure which contains the desired application logic.</p><p>Notice that instead of using echo to output the string we\'re returning it. That\'s because whether you route to a closure or route to a controller action, you should always return your response. This allows Laravel to handle many situations in a robust way.</p><p><br></p><p><span style=\"color: rgb(113, 221, 55);\">Laravel Starter The definitive introduction to the Laravel PHP web&nbsp;development framework, 2012</span></p><p><span style=\"color: rgb(113, 221, 55);\">Shawn McCool</span></p><p><br></p><p><span style=\"color: rgb(55, 65, 81);\">The Route class is a router facade (a facade is a class that serves as a kind of \"control panel\" for one of the framework\'s subsystems).</span></p><p><br></p><p>The Laravel router, when browsing the list of routes, selects the very first route that has a matching template path and an acceptable HTTP method. The rest of the routes are not examined in this process.</p><p>In your case, the login page is located at the path `/login/`. When browsing the list of routes, the router discovers that this path matches the template path of the second route, which leads to the `detail()` action of the `BbsController` (responsible for displaying the announcement page). Attempting to retrieve an announcement with the key \"login\" fails, resulting in the generation of a 404 error.</p><p>To address this issue, you can simply move the route leading to the `detail()` action of the `BbsController` to the very end of the route list. This ensures that the route for the login page is checked first, preventing conflicts with other routes.</p><p>By placing the route for the `detail()` action at the end, Laravel will prioritize routes above it, and the conflict with the login page route will be avoided.</p><p><br></p><p><span style=\"color: rgb(113, 221, 55);\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP, 2021</span></p>','[\"closure\", \"HTTP verbs\"]','2023-12-05 18:27:26','2023-12-11 21:13:24'),(18,1,'Creating a record','<p>Now, let\'s test the User model and learn a bit about Eloquent in the process. In this application, we\'re going to interact with the User model in a few ways. We\'ll want to use the Create, Retrieve, Update, and Delete methods for user records. These common methods are referred to as CRUD methods.</p><p>Eloquent simplifies development by removing the need to manually implement CRUD methods for your models. If you\'ve ever designed models without an ORM, you are already aware that this alone can save you many hours on large sites.</p><p>Now, let\'s explore the various ways in which you can create new user records. We\'ll repurpose our test route from the previous step to help us get to know Eloquent. Update the route declaration with the following code:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">Route::get(\'test\', function()\n{\n&nbsp;$user = new User;\n&nbsp;$user-&gt;email = \"test@test.com\";\n&nbsp;$user-&gt;real_name = \"Test Account\";\n&nbsp;$user-&gt;password = \"test\";\n&nbsp;$user-&gt;save();\n&nbsp;return \"The test user has been saved to the database.\";\n});\n</pre><p><br></p><p>Let\'s review:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$user = new User;\n</pre><p><br></p><p>First, we create a new instance of our User model and store it in the $user variable:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$user-&gt;email = \"test@test.com\";\n$user-&gt;real_name = \"Test Account\";\n$user-&gt;password = \"test\";\n</pre><p><br></p><p>Then, we set some attributes in our User model. These attributes directly correspond to the fields in our users database table.</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$user-&gt;save();\n</pre><p><br></p><p>Next, we tell Eloquent that we want to save the contents of this model to the database.</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">return \"The test user has been saved to the database.\";\n</pre><p><br></p><p>Finally, we output this string to the browser so that we know that all is well.</p><p><br></p><p>4. Let\'s add another entry using a different method:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">&nbsp;&nbsp;&gt;&gt;&gt; $bb = $bb-&gt;create([\'title\' =&gt; \'Пылесос\',\n&nbsp;&nbsp;... \'content\' =&gt; \'Старый, ржавый, без шланга\', \'price\' =&gt; 1000]);\n&nbsp;&nbsp;```\n</pre><p>&nbsp;&nbsp;The create() method creates a new record, inserts values into its fields from the specified associative array, saves the record, and returns it as a result. It uses mass assignment, where values are assigned simultaneously to multiple fields of the created record. Note that in this way, values can only be assigned to fields listed in the mass assignment accessible list (defined by the fillable property of the model class – see section 1.8).</p><p><br></p><p>&nbsp;&nbsp;Interestingly, the create() method, although called on the model, is executed by the query builder — a subsystem that, based on the parameters we specify for data selection (filter conditions, sorting of records, set of displayed fields, etc.), forms a ready-made SQL query, sends it to the database, retrieves the result, and presents it in a convenient form for processing. When attempting to call the query builder method on the model, its object creates a new query builder object and \"passes\" the method call to it.</p><p><br></p><p>5. Let\'s add two more entries:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">&nbsp;&nbsp;&gt;&gt;&gt; $bb = Bb::create([\'title\' =&gt; \'Грузовик\',\n&nbsp;&nbsp;... \'content\' =&gt; \'Грузоподъемность - 5 т\', \'price\' =&gt; 10000000]);\n&nbsp;&nbsp;&gt;&gt;&gt; $bb = Bb::create([\'title\' =&gt; \'Снег\', \'content\' =&gt; \'Прошлогодний\',\n&nbsp;&nbsp;... \'price\' =&gt; 50]);\n&nbsp;&nbsp;```\n</pre><p>&nbsp;&nbsp;</p><p>Query builder methods can be called not only on the model object but also on its class – as static methods.</p><p><br></p><p>7. Let\'s see what this entry is:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">&nbsp;&nbsp;&gt;&gt;&gt; echo $bb-&gt;title, \' | \', $bb-&gt;content, \' | \', $bb-&gt;price;\n&nbsp;&nbsp;```\n</pre><p>&nbsp;&nbsp;</p><p>Output:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">&nbsp;&nbsp;Пылесос | Старый, ржавый, без шланга | 1000.0\n&nbsp;&nbsp;```\n</pre><p>&nbsp;&nbsp;</p><p>You can retrieve values stored in the fields of a record by accessing the model\'s named properties.</p>','[\"CRUD\", \"fillable\", \"save\", \"create\", \"query builder\"]','2023-12-05 18:32:02','2023-12-07 09:43:39'),(19,1,'Controllers','<p>You\'ll notice that our Users_Controller class extends Laravel\'s default Base_Controller class. This is a good practice because if we need some code or configurations to affect all of our controllers, we can just edit the file pplication/controllers/base.php and make changes to the Base_Controller class. Every controller that extends the Base_Controller class will be affected.</p><p>You\'ll also notice that we have defined a controller action named index. A controller action is a method within a controller class that we intend to be the destination for a route. You may decide to create methods within a controller class that will only be called from other methods within that class; these would not be actions.</p><p>Controller actions are named with the prefix action_. This is an important distinction because we do not want users to be able to access methods within our controller that aren\'t actions.</p><p>So, now that we have this controller how can we access the index action from our browser? For now, we can\'t. We haven\'t routed any URL to that controller action. So, let\'s do that. Open up application/routes.php and add the following line:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">Route::controller(\'users\');\n</pre><p><br></p><p>As you can see, we can register an entire controller with the router with one command. Now, we can access our users controller\'s index action with http://myfirst.dev/users/index. The index action is also considered to be the default action for a controller, so we can also access our index action at http://myfirst.dev/users.</p><p>t\'s important to note that while routing to closures is convenient, routing to controllers is generally considered better practice for a few reasons. Controllers are not loaded into memory until their routes are accessed, which helps to reduce the memory footprint of your application.&nbsp;</p><p>They also make maintenance easier by making it quite clear where the developer can find the code for the route. Controllers are derived from a base class, so it\'s simple to make a change in one class and through inheritance have that change affect other classes. Finally, since controllers are actions grouped by purpose, it\'s often quite convenient to assign filters on a per-controller basis. We\'ll talk more about filters in the section Top 5 features you need to know about.</p>','[\"actions\"]','2023-12-05 19:05:52','2023-12-06 16:45:16'),(20,1,'Views','<p>Now we can go to http://myfirst.dev/users and access the index method of our controller. That\'s pretty cool, but our users controller\'s index page needs to show us a list of the users in the system. To display a list of users, we\'re going to need to create a view.</p><p>A view is a file that contains formatting data (typically HTML). PHP variables, conditionals, and loops are used within the view to display and format dynamic content.</p><p>Laravel provides its own templating system called Blade. Blade removes PHP tags and provides shortcuts for common tasks so that your views are cleaner and easier to create and maintain.</p><p>The convention is to name the view file after the controller action in which it\'s used. In this example, we\'re using Blade. If you do not wish to use Blade simply name the file index.php.</p><p>Now, we\'ll make a modification to the users controller\'s index action:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function action_index()\n{\n&nbsp;return View::make(\'users.index\');\n}&nbsp;\n</pre><p>Now, where we were previously returning a string, we\'ll return a View object. Let\'s take a closer look at what\'s happening here.</p><p>The View class make() method is a factory method that is used to generate View objects. In this case, we\'re passing the argument users.index. This is Laravel\'s internal notation for referring to view files. The notation is made up of the path to the view file relative to the application/views directory including the filename without its file extension. For example, application/views/users/index.php would be written as users.index, and application/views/admin/users/create.php would be written as admin.users.create.</p><p>Step 8 – Passing data from a controller to a view</p><p>The fact that we can go to a URL and see the view file that we created is pretty cool. But, we need to be able to see the list of users from our database. To accomplish this goal, we\'ll first query the User model from our controller action, and then pass that data to the view. Finally, we\'ll update our view to display the user data received from the controller.</p><p>Let\'s start by updating our users controller\'s index action:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function action_index()\n{\n&nbsp;$users = User::all();\n&nbsp;return View::make(\'users.index\')-&gt;with(\'users\', $users);\n}\n</pre><p>Let\'s look at this line by line:</p><pre class=\"ql-syntax\" spellcheck=\"false\">$users = User::all();\n</pre><p>First, we request all users as objects from Eloquent. If we have no rows in our users table, $users will be an empty array. Otherwise, $users will be an array of objects. These objects are instantiations of our User class.</p><pre class=\"ql-syntax\" spellcheck=\"false\">return View::make(\'users.index\')-&gt;with(\'users\', $users);\n</pre><p>Then, we modify the creation of our View object a bit. We chained a new method named with(). The with() method allows us to pass data from the controller into the view. This method accepts two arguments. The first argument is the name of the variable that will be created in the view. The second argument will be the value of that variable.&nbsp;</p><p>Blade is easy to understand and results in much more elegant code. The {{ }} tags output the results of the expression within them and replace a typical echo command. Other constructions such as if(), foreach(), and for() are the same, but without PHP tags and with a preceding @.</p><p><br></p><p><span style=\"color: aqua;\">McCool Shawn Laravel Starter</span></p><p><br></p><p>Theory:</p><p>A template is a pattern for generating a page sent to the client as a response. The process of generating a page is called rendering, and the subsystem of the framework responsible for rendering is called a templating engine or a template engine.</p><p>For rendering, in addition to the template, the templating engine needs data that will be displayed on the generated page (in this case, it could be a list of ads and the content of a selected ad). This data is formatted as a special container called a template context. The template context is created by the controller as an associative array, which the templating engine transforms into a set of regular variables accessible within the template.</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function index() {\n&nbsp;&nbsp;$context = [\'bbs\' =&gt; Bb::latest()-&gt;get()];\n&nbsp;&nbsp;return view(\'index\', $context);\n}\n</pre><p>Now, let\'s add code to the template that will output the placeholder string as many times as there are ads in the list (as stored in the \'bbs\' variable available in the template):</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;tbody&gt;\n@foreach ($bbs as $bb)\n&nbsp;&nbsp;&lt;tr&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;\n&nbsp;&nbsp;&lt;/tr&gt;\n@endforeach\n&lt;/tbody&gt;\n</pre><p>The Laravel templating engine provides a set of its own commands, similar to PHP language constructs, called directives. For example, the paired directive `@foreach ... @endforeach` is equivalent to a foreach loop in PHP.</p><p><br></p><p><span style=\"color: aqua;\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP</span></p>','[\"Blade\", \"factory method\", \"with\", \"internal notation\", \"template engine\", \"directive\", \"template context\"]','2023-12-05 19:19:19','2023-12-07 17:05:34'),(21,1,'Restful Controllers','<p>We\'ve already mentioned that Laravel\'s routing system enables you to route GET, POST, PUT, and DELETE requests to closures. But we haven\'t talked about how to individually route them to controller actions.</p><p>The answer is RESTful controllers! RESTful controllers enable you to route to different controller actions based on the request method. Let\'s configure our application to use RESTful controllers.</p><p>Since all of our controller classes are derived from the Base_Controller class, we can simply add the $restful configuration to it and all of our controllers will be affected.</p><p>Update your Base_Controller class to look like this:</p><pre class=\"ql-syntax\" spellcheck=\"false\">class Base_Controller extends Controller\n{\n&nbsp;   public $restful = true;\n\n    public function __call($method, $parameters)\n&nbsp;   {\n&nbsp;       return Response::error(\'404\');\n&nbsp;   }\n}\n</pre><p>Now, every controller that extends Base_Controller (including our own Users_Controller) is a RESTful controller!</p><p>But, wait. Now, we\'ll get a 404 error when we go to http://myfirst.dev/users. This is because we are not declaring our actions the RESTful way.</p><p>Edit your Users_Controller class and change the line:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function action_index()\n</pre><p>To this:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function get_index()\n</pre><p>Unless a method is prefixed appropriately, Laravel will not route URLs to them. In this way, we can ensure that only controller actions are routable and that our web-application\'s users can\'t access other methods that may exist in our controllers by simply typing the names of the methods in their browsers.</p><p>When an action is prefixed with get_, it will only respond to the GET requests. An action prefixed with post_ will only respond to the POST requests. The same is true of put_ and delete_. This gives us more code separation and allows us to really improve the readability and maintainability of our application.</p>','[\"base controller\"]','2023-12-05 19:24:24','2023-12-09 11:13:20'),(22,1,'Form Input','<p>Now that we are receiving the data from the form, we can go ahead and create the user account.</p><p>Let\'s update our post_create() function in the Users_Controller class to add this functionality:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">public function post_create()\n{\n&nbsp; $user = new User;\n&nbsp; $user-&gt;real_name = Input::get(\'real_name\');\n&nbsp; $user-&gt;email = Input::get(\'email\');\n&nbsp; $user-&gt;password = Input::get(\'password\');\n&nbsp; $user-&gt;save();\n&nbsp; return Redirect::to (\'users\');\n}\n</pre><p>Here we\'re creating a new user record in the same way that we did in our test route. The only difference is that we\'re using Laravel\'s Input class to retrieve the data from the form.&nbsp;</p><p>Whether the data comes from a GET request\'s query string or a POST request\'s post data, the Input::get() method can be used to retrieve the data.</p><p><br></p><p><span style=\"color: aqua;\">McCool Shawn Laravel Starter, 2012</span></p><p><br></p><p>Now, we just need to create the update form and we\'ll have a full administrative system!</p><p>This is almost exactly like the create form except that we have mixed things up a little. First of all, you\'ll notice that we\'re using Laravel\'s Form class helper methods. These helper methods, like the HTML class\' helper methods, are not mandatory. However, they are recommended. They offer many of the same advantages as the HTML class\' helper methods. The Form class helper methods offer a unified interface for generating the resulting HTML tags. It\'s much easier to programmatically update HTML tag attributes by passing an array as an argument than to loop through and generate the HTML yourself.</p><p>Notice that we\'re not prepopulating the password field. It doesn\'t make sense to do so as we\'re not storing a readable version of the password in the database. Not only that, to prevent a developer from making a mistake the Form::password() method does not have the functionality to prepopulate this field at all.</p><p><br></p><p><span style=\"color: aqua;\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP</span></p>','[\"Form class helper\"]','2023-12-05 19:27:29','2023-12-08 13:53:27'),(23,1,'Links','<p>We need a link from the users index view to the create user form as it\'s currently inaccessible from the user interface. Go ahead and add the link to the file application/views/users/&nbsp;</p><p>index.blade.php with the following line of code:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">{{ HTML::link(\'users/create\', \'Create a User\') }}\n</pre><p><br></p><p>Laravel\'s HTML class can be used to create a variety of HTML tags. You might be asking yourself why you wouldn\'t simply write the HTML for the link yourself. One very good reason to use Laravel\'s HTML helper class is that it provides a unified interface for creating tags that may need to change dynamically. Let\'s look at an example to clarify this point.</p><p>Let\'s say that we want that link to look like a button and our designer created a sweet CSS class named btn. We need to update the call to HTML::link() to include the new class attribute:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">{{ HTML::link(\'users/create\', \'Create a User\', array(\'class\' =&gt; \'btn\')) }}\n</pre><p><br></p><p>Actually, we could include any number of attributes to that class and they\'d all be handled appropriately. Any attribute assigned to the HTML elements can be updated dynamically by passing a variable to that method instead of declaring it inline.</p>','[\"HTML helper class\"]','2023-12-06 17:48:17','2023-12-06 17:49:28'),(24,1,'Deleting a record','<p>Now that we can add users, we may want to do a bit of cleanup. Let\'s add a delete action to our users controller.</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function get_delete($user_id)\n{\n   &nbsp;$user = User::find($user_id);\n&nbsp;   if(is_null($user))\n&nbsp;   {\n&nbsp;       return Redirect::to(\'users\');\n&nbsp;   }\n&nbsp;   $user-&gt;delete();\n&nbsp;   return Redirect::to(\'users\');\n}\n</pre><p>Now, let\'s step through this.</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function get_delete($user_id)\n</pre><p>This is the first time that we\'ve declared a parameter in a controller action. In order to delete a user, we need to know which user to delete. Since we have used Route::controller(\'users\') to have Laravel automatically handle the routing for our controller, it\'ll know that when we go to the URL http://myfirst.dev/users/delete/1 it should route to the delete action and pass additional URI segments as arguments to the method.</p><p>Next, we need to verify that a user with the specified user ID actually exists.</p><pre class=\"ql-syntax\" spellcheck=\"false\">$user = User::find($user_id);\n</pre><p>This line tells Eloquent to find a user with an ID that matches the argument. If a user is found, the $user variable will be populated with an object that is an instance of our User class. If not, the $user variable will contain a null value.</p><pre class=\"ql-syntax\" spellcheck=\"false\">if(is_null($user))\n{\n&nbsp;   return Redirect::to(\'users\');\n}\n</pre><p>Here, we\'re checking if our user variable has the null value indicating that the requested user was not found. If so, we\'ll redirect back to the users index.</p><pre class=\"ql-syntax\" spellcheck=\"false\">$user-&gt;delete();\nreturn Redirect::to(\'users\');\n</pre><p>Next, we delete the user and redirect back to the users index.</p><p><br></p><p><em style=\"color: rgb(113, 221, 55);\">McCool, Shawn Laravel Starter, 2012</em></p><p><br></p><p><br></p><p>Now, let\'s delete the ad for selling last year\'s snow (unlikely to be in demand):</p><pre class=\"ql-syntax\" spellcheck=\"false\">$bb = Bb::where(\'title\', \'Snow\')-&gt;first();\n$bb-&gt;delete();\n</pre><p>We search for the ad using the `where()` method (since the comparison operator is not specified, the equality operator `=` will be used). The `first()` method returns the first record from the result. The `delete()` method of the model deletes the current record.</p><p><br></p><p>Dependency Injection Theory:</p><p>A URL parameter is a value present in the path received in the client\'s request. The designation of a URL parameter is recorded in the route template under a unique name. The value passed in the path through the URL parameter is subsequently sent to the controller action associated with the route through a parameter whose name matches the name of the URL parameter itself.</p><p>For example, to extract the key from the path format /&lt;ad key&gt;/, you can create a URL parameter in the route template with the name \'bb\'. To send it to the action associated with this route, declare a parameter in the action with the same name - \'bb\'. The matching of URL parameter names and action parameters serves as a kind of \"hint\" to the framework to inject the value of the corresponding URL parameter into the action parameter. This automatic injection of required values into method parameters based on the matching of names and/or types of these parameters is called dependency injection.</p><p>Practice:</p><p>Let\'s implement the display of a specific ad selected by the website visitor. To do this, add a \'detail()\' action to the BbsController that will be executed when a GET request is made to the path format /&lt;ad key&gt;/. To extract the ad key from the path, declare a URL parameter named \'bb\' in the route template.</p><p>1. Open the routes\\web.php module, which contains the list of web routes, and add a route associated with the \'detail()\' action of the BbsController:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Route::get(\'/\', [BbsController::class, \'index\']);\nRoute::get(\'/{bb}\', [BbsController::class, \'detail\']);\n</pre><p>No trailing slash in the route templates. URL parameter names are enclosed in curly braces (e.g., {bb} is a URL parameter named \'bb\').</p><p>2. Open the app\\Http\\Controllers\\BbsController.php module, which contains the BbsController code, in a text editor and add the \'detail()\' action:</p><pre class=\"ql-syntax\" spellcheck=\"false\">class BbsController extends Controller {\n  &nbsp;&nbsp;public function detail($bb) {\n&nbsp;&nbsp;    &nbsp;&nbsp;$bb = Bb::find($bb);\n&nbsp;&nbsp;&nbsp;&nbsp;    $s = $bb-&gt;title . \"\\r\\n\\r\\n\";\n&nbsp;&nbsp;&nbsp;&nbsp;    $s .= $bb-&gt;content . \"\\r\\n\";\n&nbsp;&nbsp;&nbsp;&nbsp;    $s .= $bb-&gt;price . \" руб.\\r\\n\";\n\n&nbsp;&nbsp;&nbsp;&nbsp;    return response($s)-&gt;header(\'Content-Type\', \'text/plain\');\n&nbsp;&nbsp;    }\n}\n</pre><p>Now, let\'s simplify the \'detail()\' action code.</p><p>4. Instruct the framework to inject into the \'bb\' parameter of the \'detail()\' action not the key of the input record, but directly the object of this record by making the following changes to the code:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function detail(Bb $bb) {\n&nbsp;&nbsp;  $s = $bb-&gt;title . \"\\r\\n\\r\\n\";\n}\n</pre><p>We specified the Bb model class as the type for the \'bb\' parameter. Laravel will intelligently find the record based on the received key and substitute the object of the model containing it into this parameter. The expression that searches for the record becomes unnecessary and can be removed.</p><p>Not all web frameworks implement dependency injection. For example, Django, a popular framework written in Python, does not have this capability.</p><p><br></p><p><em style=\"color: rgb(113, 221, 55);\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP, 2021</em></p>','[\"where\", \"dependency injection\", \"header\"]','2023-12-06 17:53:54','2023-12-09 11:37:35'),(25,1,'Updating a record','<p>So, we can add and delete users, but what if we have made a typo and want to fix it? Let\'s update our users controller with the methods that are necessary for us to display our update form and then to retrieve the data from it in order to update the user record:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function get_update($user_id)\n{\n&nbsp;$user = User::find($user_id);\n&nbsp;if(is_null($user))\n&nbsp;{\n&nbsp;return Redirect::to(\'users\');\n&nbsp;}\n&nbsp;return View::make(\'users.update\')-&gt;with(\'user\', $user);\n}\n</pre><p>Here we have our new get_update() method. This method accepts a user ID as an argument. Much like we did with the get_delete() method, we need to load the user record from the database to verify that it exists. Then, we\'ll pass that user to the update form.</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function post_update($user_id)\n{\n&nbsp;$user = User::find($user_id);\n&nbsp;if(is_null($user))\n&nbsp;{\n&nbsp;return Redirect::to(\'users\');\n&nbsp;}\n&nbsp;$user-&gt;real_name = Input::get(\'real_name\');\n&nbsp;$user-&gt;email = Input::get(\'email\');\n&nbsp;if(Input::has(\'password\'))\n&nbsp;{\n&nbsp;$user-&gt;password = Input::get(\'password\');\n&nbsp;}\n&nbsp;$user-&gt;save();\n&nbsp;return Redirect::to(\'users\');\n}\n</pre><p>When a user submits our update form, they\'ll be routed to post_update().</p><p>You may have noticed a common theme with methods that receive a user ID as an argument.&nbsp;</p><p>Whenever we are going to interact with a user model we need to know for sure that the database record exists and that the model is populated. We must always first load it and validate that it is not null.</p><p>Afterwards, we assign new values to the real_name and email attributes. We don\'t want to just change the user\'s password every time we submit a change. So, we\'ll first verify that the password field wasn\'t left blank. Laravel\'s Input class\' has() method will return false, if an attribute either wasn\'t sent in the form post or if it\'s blank. If it\'s not blank, we can go ahead and update the attribute in the model.</p><p>We then save the changes to the user and redirect back to the users index page.</p><p><br></p><p><span style=\"color: rgb(113, 221, 55);\">Shawn McCool Laravel starter</span></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">use App\\Models\\Bb;\n\nclass HomeController extends Controller {\n&nbsp;&nbsp;// Other code...\n\n&nbsp;&nbsp;public function showEditBbForm(Bb $bb) {\n&nbsp;&nbsp;&nbsp;&nbsp;return view(\'bb_edit\', [\'bb\' =&gt; $bb]);\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;public function updateBb(Request $request, Bb $bb) {\n&nbsp;&nbsp;&nbsp;&nbsp;$bb-&gt;fill([\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'title\' =&gt; $request-&gt;title,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'content\' =&gt; $request-&gt;content,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'price\' =&gt; $request-&gt;price\n&nbsp;&nbsp;&nbsp;&nbsp;]);\n&nbsp;&nbsp;&nbsp;&nbsp;$bb-&gt;save();\n&nbsp;&nbsp;&nbsp;&nbsp;return redirect()-&gt;route(\'home\');\n&nbsp;&nbsp;}\n}\n</pre><p>In the `showEditBbForm()` action, don\'t forget to include the selected record in the template context so that its field values can be populated into the input fields of the web form.</p><p>In the `updateBb()` action, we specified two parameters: `Request` type for the request object and `Bb` type for the model object representing the selected announcement. Laravel\'s dependency injection system will automatically inject the required values into these parameters.</p><p>For mass assignment of updated values to the announcement fields, we use the `fill()` method of the model object. Save the record by calling the `save()` method.</p><p>In the form action of the template that saves the updated announcement, we specified the allowed HTTP method as PATCH. The issue is that PATCH is not supported by web browsers, so we cannot include it in the method attribute of the `&lt;form&gt;` tag. However, we can place a hidden field in the form with the desired HTTP method using the `@method` directive of the template engine.</p><p>Add a constant `BB_ERROR_MESSAGES` with a list of input error messages to the `HomeController`:</p><pre class=\"ql-syntax\" spellcheck=\"false\">class HomeController extends Controller {\n&nbsp;&nbsp;// Other code...\n&nbsp;&nbsp;private const BB_ERROR_MESSAGES = [\n&nbsp;&nbsp;&nbsp;&nbsp;\'price.required\' =&gt; \'You cannot give away products for free\',\n&nbsp;&nbsp;&nbsp;&nbsp;\'required\' =&gt; \'Fill in this field\',\n&nbsp;&nbsp;&nbsp;&nbsp;\'max\' =&gt; \'Value should not exceed :max characters\',\n&nbsp;&nbsp;&nbsp;&nbsp;\'numeric\' =&gt; \'Enter a number\'\n&nbsp;&nbsp;];\n&nbsp;&nbsp;// Other code...\n}\n</pre><p>The list of error messages is defined as an associative array, where each element sets a message for a specific rule. We provided a separate message for the `required` rule applied to the title input field, prohibiting giving away products for free. We then set a general message for the same rule without specifying a particular control, which will be displayed for other elements. Instead of the `:max` literal in the third error message, Laravel will substitute the length of the string specified in the `max` rule.</p><p>If an error message is not specified, Laravel will display a default message in English. However, there is an additional library that contains error messages in other languages, which we will explore in Chapter 28.</p><p>Add validation code to the `storeBb()` and `updateBb()` actions of the same controller:</p><pre class=\"ql-syntax\" spellcheck=\"false\">public function storeBb(Request $request) {\n&nbsp;&nbsp;$validated = $request-&gt;validate(self::BB_VALIDATOR, self::BB_ERROR_MESSAGES);\n&nbsp;&nbsp;Auth::user()-&gt;bbs()-&gt;create([\n&nbsp;&nbsp;&nbsp;&nbsp;\'title\' =&gt; $validated[\'title\'],\n&nbsp;&nbsp;&nbsp;&nbsp;\'content\' =&gt; $validated[\'content\'],\n&nbsp;&nbsp;&nbsp;&nbsp;\'price\' =&gt; $validated[\'price\']\n&nbsp;&nbsp;]);\n&nbsp;&nbsp;return redirect()-&gt;route(\'home\');\n}\n</pre><p>If validation fails, Laravel will store all form data and input error messages in the server session, then redirect back to the previous page—the one containing the web form. This allows the visitor to correct incorrect data.</p><p>Now, let\'s make sure that error messages and previously entered, but invalidated data are displayed on the pages with the add and edit announcement web forms.</p><p>Open the `bb_edit.blade.php` template and add code to display input error messages for the title field:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;div class=\"form-group\"&gt;\n&nbsp;&nbsp;&lt;input name=\"title\" id=\"txtTitle\" class=\"form-control @error(\'title\') is-invalid @enderror\" value=\"{{ $bb-&gt;title }}\"&gt;\n&nbsp;&nbsp;@error(\'title\')\n&nbsp;&nbsp;&lt;span class=\"invalid-feedback\"&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;strong&gt;{{ $message }}&lt;/strong&gt;\n&nbsp;&nbsp;&lt;/span&gt;\n&nbsp;&nbsp;@enderror\n&lt;/div&gt;\n</pre><p>The `@error` directive displays the content inside it only if there is an input error message in the server session for the control with the specified name. Inside the directive\'s body, you can use the `message` variable, which contains the error message as text. We use this directive to display the error message below the input field and apply the Bootstrap framework\'s `is-invalid` styling class to mark the control as having an incorrect value.</p><p>Add similar code to the template for the add announcement page (`bb_add.blade.php`) to display input error messages.</p><p>Add code to the same templates to populate the input fields with previously entered values (the corrections in the title input field are shown; the corrections for the other edit elements will be similar):</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;input ... value=\"{{ old(\'title\', $bb-&gt;title) }}\"&gt;\n</pre><p>The `old()` function retrieves the value stored in the server session for the control with the specified name. During the first display of the page, the session does not have a title value, so the `old()` function will return the value from the second parameter—the initial product name obtained by the controller from the database. If validation fails, the page will be displayed again, and in this case, the session will store the title value, which will then be entered into the input field.</p><p>Apply similar changes to the code creating the content and price control elements.</p><p>Now, log in as any user, try to add an announcement without specifying any value (for example, the product name), click the Add button, and check if the error message is displayed.</p><p><br></p><p><span style=\"color: rgb(113, 221, 55);\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP</span></p>','[\"has\", \"dependency injection\", \"fill\", \"save\", \"patch\", \"method directive\", \"validation\", \"error directive\", \"old\"]','2023-12-06 17:59:38','2023-12-09 08:20:35'),(26,1,'Relationships','<p>Eloquent is Laravel\'s native ActiveRecord implementation. It is built upon Laravel\'s Fluent Query Builder. Due to the way in which Eloquent operates with Fluent, complex queries and relationships are easy to describe and understand.</p><p>ActiveRecord is a design pattern that describes an object-oriented way of interacting with your database. For example, your database\'s users table contains rows and each of these rows represents a single user of your site. Your User model is a class that extends the Eloquent Model class. When you query a record from your database, an instantiation of your User model class is created and populated with the information from the database.</p><p>A distinct advantage of ActiveRecord is that your data and the business logic that is related to the data are housed within the same object. For example, it\'s typical to store the user\'s password in your model as a hash, to prevent it from being stored as plaintext. It\'s also typical to store the method, which creates this password hash within your User class.</p><p>Another powerful aspect of the ActiveRecord pattern is the ability to define relationships between models. Imagine that you\'re building a blog site and your users are authors who must be able to post their writings. Using an ActiveRecord implementation, you are able to define the parameters of the relationship. The task of maintaining this relationship is then simplified dramatically. Simple code is the easy code to change. Difficult to understand code is the easy code to break.</p><p>As a PHP developer, you\'re probably already familiar with the concept of database normalization.&nbsp;</p><p>If you\'re not, normalization is the process of designing databases so that there is little redundancy in the stored data. For example, you wouldn\'t want to have both a users table which contains the user\'s name and a table of blog posts which also contains the author\'s name. Instead, your blog post record would refer to the user using their user ID. In this way we avoid synchronization problems and a lot of extra work!</p><p>There are a number of ways in which relationships can be established in normalized database schemas.</p><p><br></p><p>One-to-one relationship</p><p>When a relationship connects two records in a way that doesn\'t allow for more records to be related, it is a one-to-one relationship. For example, a user record might have a one-to-one relationship with a passport record. In this example, a user record is not permitted to be linked to more than one passport record. Similarly, it is not permitted for a passport record to relate to more than one user record.</p><p>How would the database look? Your users table contains information about each user in your database. Your passports table contains passport numbers and a link to the user which owns the passport.</p><p>In this example, each user has no more than one passport and each passport must have an owner. The passports table contains its own id column which it uses as a primary key. It also contains the column user_id, which contains the ID of the user to whom the passport belongs. Last but not least, the passports table contains a column for the passport number.</p><p>First, let\'s model this relationship in the User class:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">class User extends Eloquent\n{\n&nbsp;public function passport()\n&nbsp;{\n&nbsp;return $this-&gt;has_one(\'Passport\');\n&nbsp;}\n}\n</pre><p>We created a method named passport() that returns a relationship. It might seem strange to return relationships at first. But, you\'ll soon come to love it for the flexibility it offers.</p><p>You\'ll notice that we\'re using the has_one() method and passing the name of the model as a parameter. In this case, a user has one passport. So, the parameter is the name of the passport model class. This is enough information for Eloquent to understand how to acquire the correct passport record for each user.</p><p>Now, let\'s look at the Passport class:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">class Passport extends Eloquent\n{\n&nbsp;public function users()\n&nbsp;{\n&nbsp;return $this-&gt;belongs_to(\'User\');\n&nbsp;}\n}\n</pre><p>We\'re defining the passport\'s relationship differently. In the User class, we used the has_one() method. In the Passport class we used belongs_to().</p><p>It\'s vital to identify the difference early so that understanding the rest of the relationships is more simple. When a database table contains a foreign key, it is said that it belongs to a record in another table. In this example, our passports table refers to records in the users table through the foreign key user_id. Consequently, we would say that a passport belongs to a user. Since this is a one-to-one relationship the user has one (has_one()) passport.</p><p>Let\'s say that we want to view the passport number of the user with the id of 1.</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$user = User::find(1);\nIf(is_null($user))\n{\n&nbsp;echo \"No user found.\";\n&nbsp;return;\n}\nIf($user-&gt;passport)\n{\n&nbsp;echo \"The user\'s passport number is \" . $user-&gt;passport-&gt;number;\n}\nelse\n{\n&nbsp;echo \"This user has no passport.\";\n}\n</pre><p>In this example, we\'re dutifully checking to make sure that our user object was returned as expected. This is a necessary step that should not be overlooked. Then, we check whether or not the user has a passport record associated with it. If a passport record for this user exists, the related object will be returned. If it doesn\'t exist, $user-&gt;passport will return null. In the preceding example, we test for the existence of a record and return the appropriate response.</p><p><br></p><p><span style=\"color: rgb(113, 221, 55);\">Shawn McCool Laravel starter</span></p><p><br></p><p>1. Open the `app\\Models\\User.php` module in a text editor with the User model class and add code declaring a \"direct\" relationship between the current, primary, and specified secondary models:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">use App\\Models\\Bb;\n\nclass User extends Authenticatable {\n&nbsp;&nbsp;// Other code...\n&nbsp;&nbsp;public function bbs() {\n&nbsp;&nbsp;&nbsp;&nbsp;return $this-&gt;hasMany(Bb::class);\n&nbsp;&nbsp;}\n}\n</pre><p>A \"direct\" relationship is declared as a regular method (in this case, `bbs()`). Inside the method, the `hasMany()` method of the model class is invoked, taking the name of the associated secondary model class and returning the created relationship object. This object should be returned from the method declaring the relationship.</p><p>2. Open the `app\\Models\\Bb.php` module in a text editor with the Bb model class and add code declaring an \"inverse\" relationship between the current, secondary, and specified primary models:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">use App\\Models\\User;\n\nclass Bb extends Model {\n&nbsp;&nbsp;// Other code...\n&nbsp;&nbsp;public function user() {\n&nbsp;&nbsp;&nbsp;&nbsp;return $this-&gt;belongsTo(User::class);\n&nbsp;&nbsp;}\n}\n</pre><p>An \"inverse\" relationship is also declared using a method (in this case, `user()`). The `belongsTo()` method of the model class takes the name of the associated primary model class and returns the created relationship object, which should be returned from the method declaring the relationship.</p><p>3. Add the declaration on behalf of this user:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">use App\\Models\\Bb;\n\n$bb = new Bb();\n$bb-&gt;title = \'Vacuum Cleaner\';\n$bb-&gt;content = \'Old, rusty, without a hose\';\n$bb-&gt;price = 500;\n$user-&gt;bbs()-&gt;save($bb);\n</pre><p>The method of the primary model declaring the \"direct\" relationship returns the \"direct\" relationship object. The latter supports the `save()` method, which links the passed secondary model record to the current record and simultaneously saves the passed record.</p><p>4. Create another announcement using a different method:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$user-&gt;bbs()-&gt;create([\n&nbsp;&nbsp;\'title\' =&gt; \'Truck\',\n&nbsp;&nbsp;\'content\' =&gt; \'Payload - 5 tons\',\n&nbsp;&nbsp;\'price\' =&gt; 10000000\n]);\n</pre><p>The \"direct\" relationship object also supports the `create()` method, familiar to us from section 1.10.</p><p>5. Add a third announcement using a third method:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$bb = new Bb([\n&nbsp;&nbsp;\'title\' =&gt; \'Wardrobe\',\n&nbsp;&nbsp;\'content\' =&gt; \'Brand new, polished, double-doored\',\n&nbsp;&nbsp;\'price\' =&gt; 1000\n]);\n$bb-&gt;user()-&gt;associate($user);\n$bb-&gt;save();\n</pre><p>The model constructor can be passed an associative array with field values (similar to the `create()` method). The \"inverse\" relationship method of the secondary model returns the \"inverse\" relationship object. The latter supports the `associate()` method, linking the passed record to the current one. After that, you need to save the created record by calling the `save()` method.</p><p><br></p><p><span style=\"color: rgb(113, 221, 55);\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP</span></p>','[\"has_one\", \"belongs_to\", \"foreign_key\", \"save\", \"create\", \"associate\", \"inverse relationship\", \"direct relationship\", \"primary model\", \"secondary model\"]','2023-12-06 18:11:19','2023-12-09 21:54:57'),(27,1,'Console','<p>The Laravel console allows you to interact with framework classes in an interactive mode. In particular, it is convenient for entering some debugging data into the information base.</p><p><br></p><p>1. To start the Laravel console, run the following command in the command line:</p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">&nbsp;&nbsp;php artisan tinker\n</pre><p><br></p><p>&nbsp;&nbsp;The command prompt is indicated by the prefix &gt;&gt;&gt;. The output of results is done without any prefix.</p><p><br></p><p>2. Check the console by displaying the full name of the Bb model class. Enter the following expressions, completing each of them by pressing the &lt;Enter&gt; key:</p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">&nbsp;&nbsp;&gt;&gt;&gt; use App\\Models\\Bb;\n&nbsp;&nbsp;&gt;&gt;&gt; echo Bb::class;\n</pre><p><br></p><p>It\'s important to note that the &gt;&gt;&gt; prefix indicates the command prompt, and the result of the command is displayed without a prefix.</p><p><br></p><p>3. Enter the last of the entered expressions in two lines:</p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">&nbsp;&nbsp;&gt;&gt;&gt; use\n&nbsp;&nbsp;... App\\Models\\Bb;\n&nbsp;&nbsp;```\n</pre><p>&nbsp;&nbsp;The prefix ... (three dots) indicates the prompt to enter the next line of a multiline expression.</p><p><br></p><p>4. Finish the Laravel console by pressing the &lt;Ctrl&gt;+&lt;Break&gt; or &lt;Ctrl&gt;+&lt;C&gt; key combination. Alternatively, you can type the exit command in the console.</p><p><br></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">&gt;&gt;&gt; $bb-&gt;save();&nbsp;\n=&gt; true&nbsp;\n</pre><p><br></p><p><span style=\"color: rgb(55, 65, 81);\">If an executed expression returns a result but does not imply explicit output, the result is still displayed on the next line, preceded by the =&gt; prefix. In the future, for brevity, such output of this kind, if not needed, will not be shown.</span></p>','[\"tinker\"]','2023-12-06 18:48:30','2023-12-10 16:15:25'),(28,1,'Displaying record','<p>Let\'s extract all ads sorted by increasing price:</p><pre class=\"ql-syntax\" spellcheck=\"false\">$bbs = Bb::orderBy(\'price\')-&gt;get();\n</pre><p>Now, let\'s extract ads with prices exceeding 1000 rubles and display them in reverse chronological order:</p><pre class=\"ql-syntax\" spellcheck=\"false\">$bbs = Bb::where(\'price\', \'&gt;\', 1000)-&gt;latest()-&gt;get();\nforeach ($bbs as $bb) {\n&nbsp;&nbsp;echo $bb-&gt;title, \' | \', $bb-&gt;created_at, \"\\r\\n\";\n}\n</pre><p>The `where()` method of the query builder filters records by the value of the field specified in the first parameter. The second parameter sets the SQL comparison operator, and the third one sets the comparison value.</p><p>The `latest()` method sorts records in descending order based on the creation timestamp (i.e., in reverse chronological order). The familiar `get()` method executes the query and returns the result.</p>','[\"orderby\", \"where\", \"latest\"]','2023-12-07 16:30:30','2023-12-07 16:30:30'),(30,1,'Inheritance of Templates','<p>Theory:</p><p>Similar to PHP classes, Laravel templates can inherit from one another (Laravel template inheritance). The base template contains code shared across all pages of the site: structural tags, metadata, links to stylesheets and scripts, tags defining layout (header, footer, navigation panel, etc.). In contrast, derived templates define content unique to each specific page.</p><p>Fragments of unique content in derived templates are formatted as so-called sections, each having a unique name. In the base template, places where the content of a particular section will be inserted are marked, identified by their names.</p><p>Following the Laravel convention, base templates are stored in the layouts folder within the resources\\views folder.</p><p>Practice:</p><p>Let\'s create a base template `resources\\views\\layouts\\base.blade.php`, where we will move all the repeating elements from the `index.blade.php` and `detail.blade.php` templates. Both of these templates will be made derivatives of `layouts\\base.blade.php`.</p><p>1. Create a layouts folder in the resources\\views folder to store the base template.</p><p>2. Open the `resources\\views\\index.blade.php` (or `detail.blade.php` from the same folder) in a text editor and save it with the name `resources\\views\\layouts\\base.blade.php`.</p><p>3. Modify the code of the base template `resources\\views\\layouts\\base.blade.php` as follows:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;html&gt;\n&lt;head&gt;\n&nbsp;&nbsp;&lt;meta charset=\"UTF-8\"&gt;\n&nbsp;&nbsp;&lt;title&gt;@yield(\'title\') :: Объявления&lt;/title&gt;\n&nbsp;&nbsp;&lt;!-- ... --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&nbsp;&nbsp;&lt;div class=\"container\"&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1 class=\"my-3 text-center\"&gt;Объявления&lt;/h1&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;@yield(\'main\')\n&nbsp;&nbsp;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre><p>The `@yield` directive of the templating engine outputs the content of the section with the name specified in parentheses. We created sections \'title\' and \'main\' for the title of the site section and the main content, respectively.</p><p>4. Open the `resources\\views\\index.blade.php` template and turn it into a derivative of the base template we just created, making the following changes:</p><pre class=\"ql-syntax\" spellcheck=\"false\">@extends(\'layouts.base\')\n@section(\'title\', \'Главная\')\n@section(\'main\')\n&nbsp;&nbsp;@if (count($bbs) &gt; 0)\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;table class=\"table table-striped\"&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- ... --&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/table&gt;\n&nbsp;&nbsp;@endif\n@endsection\n</pre><p>The `@extends` directive specifies the base template from which the current one inherits. Dots, not slashes, are used to separate folder and file names in template paths. The `@section` directive creates a section whose name is specified in the first parameter. It can be written in two formats: as a single directive, where the content of the section is specified as the second parameter, or as a paired `@section ... @endsection`, where the content is placed within the body of the directive.</p><p><br></p><p><span style=\"color: aqua;\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP</span></p>','[\"base template\", \"section\", \"yield\", \"extends\"]','2023-12-07 17:32:17','2023-12-07 17:32:17'),(31,1,'Naming','<p>1. Open the `routes\\web.php` module, which contains the list of web routes, and specify names for the routes by adding the following code:</p><pre class=\"ql-syntax\" spellcheck=\"false\">Route::get(\'/\', [BbsController::class, \'index\'])-&gt;name(\'index\');\nRoute::get(\'/{bb}\', [BbsController::class, \'detail\'])-&gt;name(\'detail\');\n</pre><p>The `get()` method of the router returns an object representing the route as a result. The `name()` method, called on the route, assigns a name specified in the parameter.</p><p>2. Open the `resources\\views\\index.blade.php` module, where the template for the list of announcements is stored, and fix the code that outputs hyperlinks to announcement pages:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;td&gt;\n&nbsp;&nbsp;&lt;a href=\"{{ route(\'detail\', [\'bb\' =&gt; $bb-&gt;id]) }}\"&gt; . . . &lt;/a&gt;\n&lt;/td&gt;\n</pre><p>The `route()` function generates a URL based on the named route, the name of which is specified in the first parameter. In the second parameter, an associative array with URL parameter values can be specified.</p><p><br></p><p><span style=\"color: rgb(113, 221, 55);\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP</span></p>','[]','2023-12-08 18:32:02','2023-12-08 18:35:10'),(35,1,'Provider','<p>Provider — a software module that defines the operation mode and certain parameters of a subsystem within a framework. For example, the previously mentioned AuthServiceProvider initializes the authentication system and provides it with necessary information, including a list of policies.</p><p>The majority of providers included in the website\'s framework are owned by Laravel itself. Others, including AuthServiceProvider, are part of the website itself, stored in the app\\Providers folder, and can be modified by a programmer if they wish to alter the operation mode of a particular framework subsystem.</p><p><br></p><p><span style=\"color: rgb(113, 221, 55);\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP</span></p>','[\"subsystem\"]','2023-12-09 08:03:41','2023-12-09 08:03:57'),(36,1,'Policy','<p>Policy — a software module that implements access control to a specific model according to defined rules. In particular, a policy can verify whether the current user is the author of a retrieved announcement from the database. If not, a page with a 403 error message will be displayed.</p><p>All policies included in the website\'s framework are stored in the app\\Policies folder (which is initially absent) and are registered in the AuthServiceProvider provider.</p><p>Practice</p><p>First, let\'s make sure that the user section, add, edit, and delete announcement pages are protected by the auth middleware, which allows access only to users who have logged in. After that, we\'ll create a BbPolicy policy that allows editing and deleting announcements only to their author.</p><p>1. Open the controller app\\Http\\Controllers\\HomeController.php and look at its constructor:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">public function __construct() {\n&nbsp;&nbsp;  $this-&gt;middleware(\'auth\');\n}\n</pre><p>The middleware() method instructs to \"pass\" all requests coming to the actions of the current controller through the specified middleware. Note that the artisan utility inserted this method call into the class constructor when creating basic access control facilities (see section 2.2).</p><p>As we can see, all controller actions are already protected from guests by the auth middleware. Let\'s move on to the policy.</p><p>2. In the command line, create the BbPolicy policy:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">php artisan make:policy BbPolicy\n</pre><p>3. Open the newly created policy app\\Policies\\BbPolicy.php and look at its code (listing 2.3).</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">namespace App\\Policies;\nuse App\\Models\\User;\nuse Illuminate\\Auth\\Access\\HandlesAuthorization;\nclass BbPolicy {\n&nbsp;&nbsp;  use HandlesAuthorization;\n&nbsp;&nbsp;  public function __construct() {\n&nbsp;&nbsp;  }\n}\n</pre><p>In Laravel, a policy is a class located in the namespace App\\Policies and using the HandlesAuthorization trait. Initially, it contains only an \"empty\" constructor, which is generally unnecessary.</p><p>4. Add code to the BbPolicy policy that implements access control:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">use App\\Models\\Bb;\nclass BbPolicy {\n&nbsp;&nbsp;  public function update(User $user, Bb $bb) {\n&nbsp;&nbsp;&nbsp;&nbsp;    return $bb-&gt;user-&gt;id === $user-&gt;id;\n&nbsp;&nbsp;  }\n&nbsp;&nbsp;  public function destroy(User $user, Bb $bb) {\n&nbsp;&nbsp;&nbsp;&nbsp;    return $this-&gt;update($user, $bb);\n&nbsp;&nbsp;  }\n}\n</pre><p>This code is written as a set of methods, each of which is called when attempting a specific operation (update() for editing, destroy() for deletion, etc.). The first parameter of these methods is the current user object. The remaining parameters can be arbitrary—usually, they are model objects representing the records being checked. Each method must return a logical value as a result: true if the operation is allowed, false if it is denied. Our methods take the object of the announcement as the second parameter. The update() method compares the key of the current user with the key of the announcement author. If they are equal (i.e., the current user is the author of the announcement), the edit operation is allowed. The destroy() method simply calls the update() method to perform a similar check.</p><p>5. Open the AuthServiceProvider.php provider code module app\\Providers\\AuthServiceProvider.php and add code associating the Bb model with the BbPolicy policy:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">class AuthServiceProvider extends ServiceProvider {\n&nbsp;&nbsp;  protected $policies = [\n&nbsp;&nbsp;&nbsp;&nbsp;    \'App\\Models\\Bb\' =&gt; \'App\\Policies\\BbPolicy\',\n&nbsp;&nbsp;  ];\n}\n</pre><p>Such associations are recorded in an associative array assigned to the protected policies property of the provider class. Each array element describes a connection between a model (its full name is specified as the key of the element) and a policy (whose full name becomes the value of the element).</p><p>6. Open the list of web routes routes\\web.php and add code specifying the application of the BbPolicy policy for edit and delete operations of the announcement:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">Route::get(\'/home/{bb}/edit\', . . . ) -&gt;name(\'bb.edit\')-&gt;middleware(\'can:update,bb\');\nRoute::patch(\'/home/{bb}\', . . . ) -&gt;name(\'bb.update\')-&gt;middleware(\'can:update,bb\');\nRoute::get(\'/home/{bb}/delete\', . . . ) -&gt;name(\'bb.delete\')-&gt;middleware(\'can:destroy,bb\');\nRoute::delete(\'/home/{bb}\', . . . ) -&gt;name(\'bb.destroy\')-&gt;middleware(\'can:destroy,bb\');\n</pre><p>The route object returned by the get(), post(), patch(), and delete() methods supports the familiar middleware() method, which sets the middleware that will handle all requests for the current route. We specified to \"pass\" requests through the can middleware for these four routes, implementing access control to models through their associated policies. The can middleware requires specifying two parameters, written after the colon separated by a comma:</p><p>- The name of the performed operation, which must match the name of one of the methods declared in the policy.</p><p>- The name of the URL parameter containing the record number. The dependency injection subsystem will find the record by its number and pass its representing object to the policy method.</p><p>In our case, when trying to go to the edit page of the Laravel record in the format /home/&lt;announcement key&gt;/edit/, the system will determine that the Bb model is associated with the BbPolice policy, call the update() method of this policy, and pass it the object of the announcement being corrected. The update() method will check if the current user is the author of the announcement and allow or, conversely, display a 403 error message.</p><p>Log in to the site on behalf of any user and try to edit some announcement. After that, by entering the internet address in the format /home/&lt;announcement key&gt;/edit/, try to edit someone else\'s announcement and make sure that the site does not allow it.</p><p><br></p><p><span style=\"color: rgb(113, 221, 55);\">Владимир Дронов: Laravel 8. Быстрая разработка веб-сайтов на PHP</span></p>','[\"middleware\", \"can\"]','2023-12-09 08:07:07','2023-12-10 12:48:53'),(37,1,'Згадка про бабусю і хліб','<p>Раптом йому згадалася бабуся, і як вона забороняла класти хліб долілиць й щоразу цілувала його, коли той падав додолу.</p>','[]','2023-12-10 14:31:23','2023-12-10 16:48:31'),(38,1,'Втрата надії, коли ти лише знайомий','<p>Задзвонив телефон і Максим став пояснювати, чим займається&nbsp;<span style=\"color: rgb(77, 81, 86);\">–</span>&nbsp;сказав, що гуляє зі знайомим. Оте \"зі знайомим\" , а не \"з товаришем\" геть підтяло сили у Артема просити у того на їжу.</p><p>Втім, він помітив, що, здається, через голод зовсім втратив здатність заздрити. Його тепер геть не хвилювало те, ще сам не має телефона.</p>','[]','2023-12-10 17:00:50','2023-12-10 17:02:52'),(39,1,'Дівчинка з виразною вимовою','<p>Дарина розмовляла як ото тітонька з телебачення. Мова її була чистою, вимова плинною й виразною, але, здавалось, вся енергія Дарини й тільки туди і йшла, в мову, наче на решту її не вистачало й з усіх інших усюд віяло холодом.</p><p>Ні, на таку покластись він не зможе.</p><p>До того ж вона завжди звала його Артемом. І він так, трясця, ніколи й не наважився запротестувати, хоч би як ненавидів такий снобізм. Тому Артем постановив, що мова - то вельми небезпечна річ, річ, од якої люди можуть стати байдужими й холодними.</p><p><br></p><p><span style=\"color: rgb(55, 65, 81);\">Darina spoke as if she were a TV news anchor: her language was pure, her pronunciation fluent and distinct. Yet, it seemed that all of Darina\'s energy flowed solely into her words, as if there was none left for everything else, and a coldness emanated from every other aspect. </span></p><p>No, he won\'t be able to rely on her.</p><p><span style=\"color: rgb(55, 65, 81);\">Moreover, she always addressed him as Artem. And he, damn it, never dared to protest, despite his disdain for such snobbery. Thus, Artem came to a conclusion that language is a perilous thing, something that can render people indifferent and icy.</span></p>','[]','2023-12-10 18:12:35','2023-12-10 21:27:41'),(40,1,'З альтернативного довідника лексикону Фейсбуку','<p>Лайкобол – обіцяє поставити лайк, але обіцянки не виконує.</p><p>Лайкзалайко – лайкає тілько тих, хто лайкає його.</p><p>Лайкосхеми – пробіли в процесі лайконабування.</p><p>Лайкотренінг – експрес-курс із розпізнавання і впорання із власними емоціями в процесі лайкання.</p><p>Балалайк – лайк, поставлений москалеви.</p><p>Лайковіри – секта, утворена після того, як Цукерберг постановить прибрати лайки.</p>','[]','2023-12-11 15:44:41','2023-12-11 15:44:41'),(41,1,'Про скіфські баби','<p><span style=\"color: rgb(5, 5, 5);\">Приходить зима і знову ловиш себе на думці, що скіфські баби - це увіковічення у камені сніговиків.</span></p>','[]','2023-12-11 15:46:33','2023-12-11 15:46:33'),(42,1,'On The Origins Of Morality','<p>wip</p>','[]','2023-12-11 15:48:48','2023-12-11 15:48:48'),(43,1,'Зимно','<p>wip</p>','[]','2023-12-11 15:49:34','2023-12-11 15:49:34'),(44,1,'Лезо Оккама','<p>З подружньої сварки:</p><p>Та запхай ти своє лезо Оккама..</p>','[]','2023-12-11 15:50:50','2023-12-11 15:50:50'),(45,1,'Премії імені Т. Шевченка','<p><span style=\"color: rgb(5, 5, 5);\">Голова національної премії імені Т. Шевченка зазначив, що премію не отримають ті, хто не дружить з головою.</span></p>','[]','2023-12-11 15:52:39','2023-12-11 15:52:39'),(46,1,'Про генератори','<p><span style=\"color: rgb(5, 5, 5);\">Найсмертельніший із енергетичних гріхів: мовчати, коли нарешті подали електрику, а в сусіда щодуху гуде генератор.</span></p>','[]','2023-12-11 15:53:22','2023-12-11 15:53:22'),(47,1,'Current User','<p>2.6. Obtaining information about the current user</p><p>The next step is to ensure that hyperlinks to pages available only to registered users are not shown to guests, and vice versa. It would also be nice to display the user\'s name in the user section — let\'s start with that.</p><p>1. Open the user section template resources\\views\\home.blade.php and insert the code that displays the heading with the \"addressed\" greeting:</p><pre class=\"ql-syntax\" spellcheck=\"false\">@section(\'main\')\n&lt;h2&gt;Welcome, {{ Auth::user()-&gt;name }}!&lt;/h2&gt;\n&lt;p . . . &gt;&lt;a . . . &gt;Add a listing&lt;/a&gt;&lt;/p&gt;\n</pre><p>Here, by calling the user() method of the Auth facade, we obtain the current user object and access the name property of this object to extract the user\'s name.</p><p>2. Open the base template resources\\views\\layouts\\base.blade.php and add the code that displays hyperlinks Registration and Login only to guests, and the hyperlink My Listings and the form with the Logout button only to registered users:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;a . . . &gt;Home&lt;/a&gt;\n@guest\n&lt;a . . . &gt;Register&lt;/a&gt;\n&lt;a . . . &gt;Login&lt;/a&gt;\n@endguest\n@auth\n&lt;a . . . &gt;My Listings&lt;/a&gt;\n&lt;form . . . &gt;\n&nbsp;. . .\n&lt;/form&gt;\n@endauth\n</pre><p>The paired @guest ... @endguest directive of the templating engine outputs its content if the user is not logged in, while the paired @auth ... @endauth directive does the opposite — it outputs its content if the user is logged in.</p>','[\"user\", \"guest\", \"endguest\", \"auth\", \"endauth\"]','2023-12-11 20:02:13','2023-12-11 20:02:13'),(48,1,'Installation','<p>You can create a new Laravel project using two methods:</p><p>1. Using the laravel utility by typing the following command:</p><pre class=\"ql-syntax\" spellcheck=\"false\">laravel new &lt;project name&gt; [--auth] [--dev] [--force]\n</pre><p>The project folder with the specified name is created in the directory where the command was issued.</p><p>The following useful options are supported:</p><p>- `--auth`: additionally installs the laravel/ui library and adds basic access control features to the project, similar to those described in sections 2.2 and 2.5. Note that templates for registration, login, and other pages created this way use the Bootstrap CSS framework and the Vue JavaScript framework, which will also be installed. If you do not plan to use Bootstrap and Vue and want to exclude their installation, create access control features using the method described in section 2.2.</p><p>- `--dev`: installs the latest version of Laravel, even if it is not stable (a release).</p><p>- `--force`: forcefully creates the project even if a folder with the specified name already exists.</p><p><br></p><p>2. Using the Composer utility by typing the following command:</p><pre class=\"ql-syntax\" spellcheck=\"false\">composer create-project --prefer-dist laravel/laravel &lt;project name&gt;\n</pre><p>The `--prefer-dist` flag specifies to install only stable releases of the libraries.</p>','[\"laravel/ui library\", \"dev\", \"force\", \"prefer-dist\", \"Bootstrap\", \"Vue\"]','2023-12-11 20:49:29','2023-12-11 20:49:29'),(49,1,'Сушені сливи','<p>Той був старший, а що візьмеш у старших. До того ж, це він, Череп ось вже декілька років поспіль, до того, як переїхала мати, кожного літа й осені брав у нього. Брав сливову сушку. Треба було чим швидше зникати звідти. Сушки вже немає, (він відчув, як до губ підійшла слина), а коли її немає, немає його данини Черепу, той лютує.</p>','[]','2023-12-13 16:30:45','2023-12-13 17:15:03'),(50,1,'Голоси','<p>Він загалом був дуже чутливим до голосів і вловлював кожний порух інтонації, кожну фальшиву ноту чи несподіваний викрутас слова. Перед сном денні голоси повертались. Наче непрошені гості вривались вони у його супокій і до перших памороків сну господарювали там як у себе вдома.</p>','[]','2023-12-13 17:26:09','2023-12-13 17:26:09'),(51,1,'Спогад про смажену бульбу','<p>Він пам\'ятав, як не раз на багатті друзі смажили бульбу. Бульба у мундирах, казала його бабуся. І віддав тоді б усе, аби тільки й цього разу традиція продовжилась. Бульба з багаття була неспівмірно смачніша, ніж та казенна, в мундирах, спечена бабусею. </p>','[]','2023-12-13 17:35:33','2023-12-13 17:35:33'),(52,1,'Голос і мова','<p>...</p>','[]','2023-12-13 17:38:31','2023-12-13 17:38:31');
/*!40000 ALTER TABLE `articles` ENABLE KEYS */;

--
-- Table structure for table `categories`
--

DROP TABLE IF EXISTS `categories`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `categories` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `parent_id` bigint unsigned DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `categories`
--

/*!40000 ALTER TABLE `categories` DISABLE KEYS */;
INSERT INTO `categories` VALUES (6,'Fiction',NULL,'2023-12-03 07:49:29','2023-12-09 20:00:04'),(8,'Голос',6,'2023-12-03 07:50:25','2023-12-09 12:40:22'),(9,'Non-fiction',NULL,'2023-12-03 07:55:42','2023-12-09 20:00:31'),(10,'Programming',9,'2023-12-03 09:34:21','2023-12-09 20:00:37'),(11,'Laravel',10,'2023-12-03 09:34:43','2023-12-09 12:40:52'),(12,'Database',11,'2023-12-03 09:35:56','2023-12-09 12:40:59'),(13,'Artisan',11,'2023-12-04 17:19:22','2023-12-09 12:41:10'),(14,'Migrations',11,'2023-12-05 17:51:05','2023-12-09 12:41:20'),(16,'Routing',11,'2023-12-05 18:23:15','2023-12-09 12:41:34'),(17,'Controllers',11,'2023-12-05 19:00:40','2023-12-09 12:41:44'),(18,'Views',11,'2023-12-05 19:16:34','2023-12-09 12:41:52'),(19,'Console',11,'2023-12-06 18:43:58','2023-12-06 18:43:58'),(20,'Providers',11,'2023-12-09 08:01:33','2023-12-09 12:39:53'),(21,'Policy',11,'2023-12-09 08:05:41','2023-12-09 19:59:55'),(22,'Мудрагелії фейсбучні',6,'2023-12-11 15:41:48','2023-12-12 16:25:12'),(23,'Installation',11,'2023-12-11 20:46:08','2023-12-12 16:25:00'),(24,'Religion',9,'2023-12-13 16:24:28','2023-12-13 16:25:34'),(25,'Christ',24,'2023-12-13 16:25:09','2023-12-13 16:25:45'),(26,'Ideas',8,'2023-12-13 17:37:08','2023-12-13 17:37:39');
/*!40000 ALTER TABLE `categories` ENABLE KEYS */;

--
-- Table structure for table `failed_jobs`
--

DROP TABLE IF EXISTS `failed_jobs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `failed_jobs` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `uuid` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `connection` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `queue` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `payload` longtext COLLATE utf8mb4_unicode_ci NOT NULL,
  `exception` longtext COLLATE utf8mb4_unicode_ci NOT NULL,
  `failed_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `failed_jobs_uuid_unique` (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `failed_jobs`
--

/*!40000 ALTER TABLE `failed_jobs` DISABLE KEYS */;
/*!40000 ALTER TABLE `failed_jobs` ENABLE KEYS */;

--
-- Table structure for table `migrations`
--

DROP TABLE IF EXISTS `migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `migrations` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `migration` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `batch` int NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `migrations`
--

/*!40000 ALTER TABLE `migrations` DISABLE KEYS */;
INSERT INTO `migrations` VALUES (1,'2014_10_12_000000_create_users_table',1),(2,'2014_10_12_100000_create_password_reset_tokens_table',1),(3,'2019_08_19_000000_create_failed_jobs_table',1),(4,'2019_12_14_000001_create_personal_access_tokens_table',1),(5,'2023_10_31_052226_add_admin_to_users',1),(6,'2023_11_04_122327_create_articles_table',2),(7,'2023_11_28_181727_create_categories_table',3),(8,'2023_11_28_182010_create_article_category_table',4);
/*!40000 ALTER TABLE `migrations` ENABLE KEYS */;

--
-- Table structure for table `password_reset_tokens`
--

DROP TABLE IF EXISTS `password_reset_tokens`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `password_reset_tokens` (
  `email` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `token` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `password_reset_tokens`
--

/*!40000 ALTER TABLE `password_reset_tokens` DISABLE KEYS */;
/*!40000 ALTER TABLE `password_reset_tokens` ENABLE KEYS */;

--
-- Table structure for table `personal_access_tokens`
--

DROP TABLE IF EXISTS `personal_access_tokens`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `personal_access_tokens` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `tokenable_type` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `tokenable_id` bigint unsigned NOT NULL,
  `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `token` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL,
  `abilities` text COLLATE utf8mb4_unicode_ci,
  `last_used_at` timestamp NULL DEFAULT NULL,
  `expires_at` timestamp NULL DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `personal_access_tokens_token_unique` (`token`),
  KEY `personal_access_tokens_tokenable_type_tokenable_id_index` (`tokenable_type`,`tokenable_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `personal_access_tokens`
--

/*!40000 ALTER TABLE `personal_access_tokens` DISABLE KEYS */;
/*!40000 ALTER TABLE `personal_access_tokens` ENABLE KEYS */;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `users` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email_verified_at` timestamp NULL DEFAULT NULL,
  `password` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `remember_token` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `admin` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`),
  UNIQUE KEY `users_email_unique` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES (1,'poedgar','poedgar@example.com',NULL,'$2y$10$hm7dpihAYM//1i6VO/d8Wu3Xc/rAsxLjY9gvE/Ux25.GT4Z92mQ1m',NULL,'2023-11-04 12:42:06','2023-11-04 12:42:06',0);
/*!40000 ALTER TABLE `users` ENABLE KEYS */;

--
-- Dumping routines for database 'sail_project_2'
--
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-12-13 20:02:30
